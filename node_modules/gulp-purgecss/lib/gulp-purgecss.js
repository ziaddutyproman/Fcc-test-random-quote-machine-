'use strict';

var glob = require('glob');
var PluginError = require('plugin-error');
var purgecss = require('purgecss');
var through = require('through2');
var applySourceMap = require('vinyl-sourcemaps-apply');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var glob__namespace = /*#__PURE__*/_interopNamespaceDefault(glob);

const PLUGIN_NAME = "gulp-purgecss";
function getFiles(contentArray, ignore) {
    return contentArray.reduce((acc, content) => {
        return [...acc, ...glob__namespace.sync(content, { ignore })];
    }, []);
}
/**
 *
 * @param options - options
 * @returns
 *
 * @public
 */
function gulpPurgeCSS(options) {
    return through.obj(async function (file, _encoding, callback) {
        // empty
        if (file.isNull())
            return callback(null, file);
        // buffer
        if (file.isBuffer()) {
            try {
                const optionsGulp = {
                    ...options,
                    content: getFiles(options.content, options.skippedContentGlobs),
                    css: [
                        {
                            raw: file.contents.toString(),
                        },
                    ],
                    stdin: true,
                    sourceMap: !!file.sourceMap,
                };
                const purgedCSSResults = await new purgecss.PurgeCSS().purge(optionsGulp);
                const purge = purgedCSSResults[0];
                const result = optionsGulp.rejected && purge.rejected
                    ? purge.rejected.join(" {}\n") + " {}"
                    : purge.css;
                file.contents = Buffer.from(result, "utf-8");
                // apply source map to the chain
                if (file.sourceMap) {
                    applySourceMap(file, purge.sourceMap);
                }
                callback(null, file);
            }
            catch (e) {
                if (e instanceof Error) {
                    this.emit("error", new PluginError(PLUGIN_NAME, e.message));
                }
            }
        }
        // stream
        if (file.isStream()) {
            let css = "";
            file.contents
                .on("data", (buffer) => {
                css += buffer.toString();
            })
                .on("end", async () => {
                try {
                    const optionsGulp = {
                        ...options,
                        css: [
                            {
                                raw: css,
                            },
                        ],
                        sourceMap: !!file.sourceMap,
                    };
                    const purgedCSSResults = await new purgecss.PurgeCSS().purge(optionsGulp);
                    const purge = purgedCSSResults[0];
                    const result = optionsGulp.rejected && purge.rejected
                        ? purge.rejected.join(" {}\n") + " {}"
                        : purge.css;
                    const streamResult = through();
                    streamResult.write(Buffer.from(result, "utf-8"));
                    file.contents = file.contents.pipe(streamResult);
                    // apply source map to the chain
                    if (file.sourceMap) {
                        applySourceMap(file, purge.sourceMap);
                    }
                    callback(null, file);
                }
                catch (e) {
                    if (e instanceof Error) {
                        this.emit("error", new PluginError(PLUGIN_NAME, e.message));
                    }
                }
            });
        }
    });
}

module.exports = gulpPurgeCSS;
